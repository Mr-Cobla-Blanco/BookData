
<!DOCTYPE html>
<html>

<head>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  
  <meta charset="utf-8">
  <base href="./">
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://unpkg.com/epubjs/dist/epub.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body, html {
  margin:0;
  padding:0;
  width: 100%;
  height: 100%;
  }

  #bookArea {
    width: 100%;
    height: 100%;
    top: 0;
    left:0; 
    padding-bottom: 7%;
    padding-top: 0 
  }
  
      #nav-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      pointer-events: none;
    }
    .nav-zone {
      flex: 1;
      pointer-events: all;
      cursor: pointer;
    }


</style>

</head>

<body>

    <div id="bookArea"></div>
  <div id="nav-overlay">
   <div class="nav-zone" id="prev-zone"></div>
   <div class="nav-zone" id="next-zone"></div>
  </div>


  <script>

  window.ReactNativeWebView.postMessage("Something started") 

  //var lastPage_WebView = "{{PAGE_WEBVIEW}}"
  //const UserFontSize = ("{{USER_FONTSIZE}}")
  let GlobalRendition = null

//setTimeout(window.ReactNativeWebView.postMessage("Hide loadingScreen"),500)

async function WordCounter(rendition,Vbook) {

//loger(".01")
const startCfi = rendition.currentLocation().start.cfi;
const endCfi = rendition.currentLocation().end.cfi;
const base = startCfi.split('!')[0] + '!';  // "epubcfi(/6/4[chap01ref]!"
const startSub = startCfi.split('!')[1].replace(/\)$/, ''); // "/4/2/10/2/1:1"
const endSub = endCfi.split('!')[1].replace(/\)$/, ''); // "/4/2/16/4/1:0"
const rangeCfi = `${base},${startSub},${endSub})`;

//loger(".02 :"+rangeCfi)
const ranger = await Vbook.getRange(rangeCfi) //.then(range => {ranger = range})
const textContent = ranger.toString()
//loger("0.SUCESS "+ textContent)
const words = textContent.trim().split(/\s+/).filter(word => word.length > 0);
//loger(".06" + words)
    const wordCount = words.length
//loger(".07 tudo certo wordCount= " + wordCount)

  return wordCount
}


async function loadBook() {

  window.ReactNativeWebView.postMessage("Pre-Fetch") 

  //Fetch relativo - mesmo diretorio
  const response = await fetch('./book.epub').then(r => window.ReactNativeWebView.postMessage("Fetch ok: " + r.status)).catch(e => window.ReactNativeWebView.postMessage("Fetch Erro: "+ e) )


  const arrayBuffer = await response.arrayBuffer()

  const book = ePub(arrayBuffer)
      //Parte responsavel por render
    const rendition = book.renderTo("bookArea", {
    width: "100%",
    height: "100%",
    spread: "none",
    
    // PERFORMANCE OPTIMIZATIONS:
    flow: "paginated",      // Faster than "scrolled" for large books
    manager: "default",
    minSpreadWidth: 0,
    spread: "none",
    snap: true,             // Snap to pages (smoother scrolling)
    allowScriptedContent: false,  // Disable if EPUB has no scripts (faster)
    resizeOnOrientationChange: true
  });

  window.ReactNativeWebView.postMessage("Hide loadingScreen")

  GlobalRendition = rendition
  
}

 window.ReactNativeWebView.postMessage("2") 

loadBook()


  function base64toByte(base64_string){
     //loger('Step 1: Starting base64 decode...');
    //loger('Base64 length:'+ base64_string.length);

    //decode base64 to binary
    const binaryString = atob(base64_string)
    //loger("Binary string length: " + binaryString.length)

    const byter = new Uint8Array(binaryString.length)

    //process in chunks
    const CHUNK_SIZE = 8192 //8KB chunks

    //for lento que passa por todos os chunks
    for (let i = 0; i < binaryString.length; i += CHUNK_SIZE) {

      const chunkEnd = Math.min(i + CHUNK_SIZE, binaryString.length);
      for (let j = i; j < chunkEnd; j++) {
        //Bem obvio que torna Binario para string
        byter[j] = binaryString.charCodeAt(j);

      }
  }

  //loger("✓ Byter carregado com o for")

  //so comeca a carregar o livro quando A webView estiver carregada
  document.addEventListener('DOMContentLoaded', function() {
  InitializeBook(byter)
  })

  }
  
  async function InitializeBook(byteArray) {

    const blober = new Blob([byteArray], { type: "application/epub+zip" });
    let CurrentWordCount = 0
    //loger('✓ Blob created:'+ blober.size + 'bytes');
    
    //Permite a UI atualizar
    await new Promise(resolve => setTimeout(resolve,0))

    const book = ePub(blober)

    // Wait for BOTH ready and opened
    await book.ready;
    //loger("✓ Book ready!", "success");

    await book.loaded.spine

    //maravilha ta funcionado

    //if (storageHrefCover = "") {}
    //const HrefCover_local = book.cover

    //Garantir q carregar a capa so vai rodar na primeira vez q o livro é aberto
if (lastPage_WebView == "" ) {

  //loger("What fuck it shoul be doing")

    const coverBlorbUrl = await book.coverUrl()
    const response = await fetch(coverBlorbUrl)
    const blob = await response.blob()

    //Converte blob da capa para base64
    const base64data = await new Promise((resolve, reject) => {
      const reader = new FileReader()

      reader.onloadend = () => {resolve(reader.result)}

      reader.onerror = () => {
        reject(new Error('Failed to read blob as Base64'));
      };

      reader.readAsDataURL(blob)
    })

    window.ReactNativeWebView.postMessage("HrefCover:"+ base64data)
    
    //Clean up Blob (If you don't do this the will get slower)
    //book.archive.revokeUrl(coverBloubUrl)

  }else{
    //Clean all previous blobs just to make sure, actually there is no need for it since only my version will have this problem

  }

    //find the first valid spine item
    let firstValidIndex = 0
    let firstValidHref = null

    if (lastPage_WebView != "" ) {firstValidIndex = lastPage_WebView } else {


    //This code find the first valid index in case the epub is malformed
      for (let i = 0; i < book.spine.length; i++) {
        const item = book.spine.get(i);
        //loger(`Checking spine item ${i}: idref=${item.idref}, href=${item.href}`);
        
        if (item.href) {
          firstValidIndex = i;
          firstValidHref = item.href;
          //loger(`✓ Found first valid spine item at index ${i}: ${firstValidHref}`);
          break;
        } else {
          //loger(`⚠ Spine item ${i} has no href, skipping...`);
          
          // Try to find in manifest by idref
          if (item.idref && book.packaging && book.packaging.manifest) {
            const manifestItem = book.packaging.manifest[item.idref];
            if (manifestItem && manifestItem.href) {
              loger(`✓ Found href in manifest for ${item.idref}: ${manifestItem.href}`);
              item.href = manifestItem.href;
              item.url = manifestItem.href;
              firstValidIndex = i;
              firstValidHref = manifestItem.href;
              break;
            } else {
            // loger(`❌ idref "${item.idref}" not found in manifest - SKIPPING`);
            }
          }
        }
      }
      
    } 
    
    await book.opened;

    /*
     book.spine.hooks.serialize.register((output, section) => {
    loger('Section href:', section.href);
     });

  
    book.loaed.spine.then(function (spine) {
      loger("Spine lenghth "+ spine.href)
      spine.each(function(item){
        loger("item href "+ item.href)
        loger("item id "+ item.id )
      })
    })*/

    //Parte responsavel por render
    const rendition = book.renderTo("bookArea", {
    width: "100%",
    height: "100%",
    spread: "none",
    
    // PERFORMANCE OPTIMIZATIONS:
    flow: "paginated",      // Faster than "scrolled" for large books
    manager: "default",
    minSpreadWidth: 0,
    spread: "none",
    snap: true,             // Snap to pages (smoother scrolling)
    allowScriptedContent: false,  // Disable if EPUB has no scripts (faster)
    resizeOnOrientationChange: true
  });

  //Responsavel por controla o tamanho da fonte
  rendition.themes.fontSize(UserFontSize);

  //Responsável por mudar a font do texto
  //alert("Vamos adicionar UserFontType_local")

  const UserFontType = ("{{USER_FONTTYPE}}")

  //alert("adicionado UserFontType_local")

  if (UserFontType != ""){
  rendition.themes.font(UserFontType) //.font(UserFontType)
  //window.ReactNativeWebView.postMessage("Boa a fonte é "+ UserFontType)
  }
  //alert("Passou do if")

  GlobalRendition = rendition

  // Set up rendered event
    rendition.on("rendered", function(section) {
    
    window.ReactNativeWebView.postMessage("Hide loadingScreen")

    //Responsavel por controla o tamanho da fonte
    rendition.themes.fontSize(UserFontSize);

    //Conta as letras quando acaba de abrir o livro
    if (CurrentWordCount == 0){
      WordCounter(rendition,book).then( (returned) => {
      CurrentWordCount = returned
      //loger(CurrentWordCount)
      })
    }
    
  });

    rendition.on("displayError", function(err) {
      loger("Display error: " + err.message);
    });

    rendition.display(firstValidIndex);


    await new Promise(resolve => setTimeout(resolve, 300));


    const section = book.spine.get(rendition.currentLocation().start.spine);
    if (section && section.content) {
      // Restaura passando o CFI inteiro (com offset)
      await rendition.display(SAVED_POSITION);
      
      // Força o scroll para o offset específico
      rendition.annotations.highlight(SAVED_POSITION, {}, () => {});
    }

   //Um listener para ser chamada quando muda de pagina
    rendition.on('relocated', function(location) {

    let localiza = rendition.currentLocation().start.cfi
    window.ReactNativeWebView.postMessage("location:"+localiza)

    //Lida com a logica do WordCounter
    window.ReactNativeWebView.postMessage("pageWordCount: "+CurrentWordCount)

    setTimeout(() => {
    try{

    WordCounter(rendition,book).then( (returned) => {
    CurrentWordCount = returned
    //loger(CurrentWordCount)
    })
  }catch (e) {loger("erro no word counter "+ e)}
  },100)

  //Parte que cuida do progresso por capitulos
  const currentPage = location.start.displayed.page;
  const totalPagesInChapter = location.start.displayed.total;
  const Obj_ChapterProgress = [
    Current = currentPage,
    Total = totalPagesInChapter
  ]

   //Responsavel por controla o tamanho da fonte
  if (currentPage == 0){rendition.themes.fontSize(UserFontSize);}
  //window.ReactNativeWebView.postMessage(`LOLA ${JSON.stringify(Obj_ChapterProgress)}`)

  window.ReactNativeWebView.postMessage(`Chapter progress:${JSON.stringify(Obj_ChapterProgress)}`);
  
  //book.location.generate(1024)
/*
  // Overall progress through the book (0 to 1)
  const progress = book.locations.percentageFromCfi(localiza) *100;
  
  //Deveria passar pagina atual e total do capitulo para mostrar, tenta passar em objeto para facilitar minha vida
  window.ReactNativeWebView.postMessage(`${(progress ).toFixed(5)}% through book check`);

//Segundo metodo-------------------------------------------------------------

  book.locations.generate(1024).then(() => {

      const currentLocation = rendition.currentLocation();
  const currentCfi = currentLocation.start.cfi;
  
  // Índice da localização atual
  const currentIndex = book.locations.locationFromCfi(currentCfi);
  
  // Total de localizações
  const totalLocations = book.locations.total;
  
  // Calcular porcentagem
  const percentage = (currentIndex / totalLocations) * 100;

  window.ReactNativeWebView.postMessage(`Progresso ${(percentage).toFixed(5)}% in second method, ${currentIndex}/${totalLocations}`);
  })*/


    
    });

  }


    //destroy a renderização se mudar de tela, para nao puxar processamento do celular
  
    window.addEventListener('focus', function() {
      window.ReactNativeWebView.postMessage("Testando Focus")
  
    });
    
    
    window.addEventListener('visibilitychange', function() {
    //window.ReactNativeWebView.postMessage("Hide loadingScreen")
          setTimeout(() => {
        window.ReactNativeWebView.postMessage("Hide loadingScreen");
      }, 1500); // 3000 = 3sec  

     if (document.hidden) {
      //if (GlobalRendition) {GlobalRendition.destroy()}
    };

    //window.ReactNativeWebView.postMessage("Hide loadingScreen")
    })
    


    document.getElementById('next-zone').addEventListener('click', function() {

      loadBook()
      if (GlobalRendition ) {
        GlobalRendition.next()
        window.ReactNativeWebView.postMessage("Page-Next")
      }
          
    })

    document.getElementById('prev-zone').addEventListener('click', function() {
          
      if (GlobalRendition) {
        GlobalRendition.prev()
        window.ReactNativeWebView.postMessage("Page-Prev")  
      }
        
    })


  </script>

</body>
</html>