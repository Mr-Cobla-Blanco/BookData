
<!DOCTYPE html>
<html>

<head>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://unpkg.com/epubjs/dist/epub.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  #loadingScreen {
    margin: 0;
    justify-content: center;
    align-items: center;
    font-size: x-large;
    top: 50%;
    left: 50%;
  }

  body, html {
  margin:0;
  padding:0;
  width: 100%;
  height: 100%;
  }

  #bookArea {
    width: 100%;
    height: 100%;
    top: 0;
    left:0; 
    padding-bottom: 7%;
    padding-top: 0 
  }
  
      #nav-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      pointer-events: none;
    }
    .nav-zone {
      flex: 1;
      pointer-events: all;
      cursor: pointer;
    }

</style>

</head>

<body>

   <div id="loadingScreen">
    <div class="load-text">Loading...</div>
   </div>

    <div id="bookArea"></div>
  <div id="nav-overlay">
   <div class="nav-zone" id="prev-zone"></div>
   <div class="nav-zone" id="next-zone"></div>
  </div>


  <script>

  var base64 = "{{BASE6_boolean}}";  
  var lastPage_WebView = "{{PAGE_WEBVIEW}}"
  let GlobalRendition = null


  function loger(message) {
    alert(message)
  }

async function WordCounter(rendition,Vbook) {

//loger(".01")
const startCfi = rendition.currentLocation().start.cfi;
const endCfi = rendition.currentLocation().end.cfi;
const base = startCfi.split('!')[0] + '!';  // "epubcfi(/6/4[chap01ref]!"
const startSub = startCfi.split('!')[1].replace(/\)$/, ''); // "/4/2/10/2/1:1"
const endSub = endCfi.split('!')[1].replace(/\)$/, ''); // "/4/2/16/4/1:0"
const rangeCfi = `${base},${startSub},${endSub})`;

//loger(".02 :"+rangeCfi)
const ranger = await Vbook.getRange(rangeCfi) //.then(range => {ranger = range})
const textContent = ranger.toString()
//loger("0.SUCESS "+ textContent)
const words = textContent.trim().split(/\s+/).filter(word => word.length > 0);
//loger(".06" + words)
    const wordCount = words.length
//loger(".07 tudo certo wordCount= " + wordCount)

  return wordCount
}


  async function diagnoseSpine(book) {
  loger("=== SPINE DIAGNOSTIC ===");
  
  // Check if spine exists
  loger("book.spine exists: " + (book.spine ? "YES" : "NO"));
  loger("book.spine.length: " + (book.spine ? book.spine.length : "N/A"));
  
  if (book.spine && book.spine.length > 0) {
    const firstItem = book.spine.get(0);
    
    // Log the entire first item object
    //loger("First spine item (full object):"+ JSON.stringify(firstItem, null, 2));
    
    // Check alternative properties
    loger("Checking alternative properties:");
    loger("  - href: " + firstItem.href);
    loger("  - url: " + firstItem.url);
    loger("  - idref: " + firstItem.idref);
    loger("  - id: " + firstItem.id);
    loger("  - canonical: " + firstItem.canonical);
    loger("  - index: " + firstItem.index);
    
    // Check if it's in the items array instead
    if (book.spine.items && book.spine.items.length > 0) {
      loger("book.spine.items[0]:");
      loger(JSON.stringify(book.spine.items[0], null, 2));
    }
    
    // Check manifest for the idref
    if (firstItem.idref && book.packaging && book.packaging.manifest) {
      loger("Looking up idref '" + firstItem.idref + "' in manifest...");
      const manifestItem = book.packaging.manifest[firstItem.idref];
      if (manifestItem) {
        loger("Found in manifest:");
        loger(JSON.stringify(manifestItem, null, 2));
      } else {
        loger("❌ NOT FOUND in manifest!", "error");
      }
    }
  }
  
  // Check the package document
  if (book.packaging) {
    loger("Packaging spine:");
    loger(JSON.stringify(book.packaging.spine, null, 2));
    
    loger("Manifest keys: " + Object.keys(book.packaging.manifest || {}).join(", "));
  }
  
  // Check the container
  if (book.container) {
    loger("Container directory: " + book.container.directory);
    loger("Container packagePath: " + book.container.packagePath);
  }
}


  function base64toByte(base64_string){
     //loger('Step 1: Starting base64 decode...');
    //loger('Base64 length:'+ base64_string.length);

    //decode base64 to binary
    const binaryString = atob(base64_string)
    //loger("Binary string length: " + binaryString.length)

    const byter = new Uint8Array(binaryString.length)

    //process in chunks
    const CHUNK_SIZE = 8192 //8KB chunks

    //for lento que passa por todos os chunks
    for (let i = 0; i < binaryString.length; i += CHUNK_SIZE) {

      const chunkEnd = Math.min(i + CHUNK_SIZE, binaryString.length);
      for (let j = i; j < chunkEnd; j++) {
        //Bem obvio que torna Binario para string
        byter[j] = binaryString.charCodeAt(j);

      }
  }

  //loger("✓ Byter carregado com o for")

  //so comeca a carregar o livro quando A webView estiver carregada
  document.addEventListener('DOMContentLoaded', function() {
  InitializeBook(byter)
  })

  }
  
  async function InitializeBook(byteArray) {

    const blober = new Blob([byteArray], { type: "application/epub+zip" });
    let CurrentWordCount = 0
    //loger('✓ Blob created:'+ blober.size + 'bytes');
    
    //Permite a UI atualizar
    await new Promise(resolve => setTimeout(resolve,0))

    //loger('Step 3: Initializing ePub...')
    const book = ePub(blober)
    //loger('✓ Book object created');

    // Wait for BOTH ready and opened
    await book.ready;
    //loger("✓ Book ready!", "success");

    await book.loaded.spine
    //loger("The spine loaded worked")

    //await diagnoseSpine(book)

    //find the first valid spine item
    let firstValidIndex = 0
    let firstValidHref = null

    if (lastPage_WebView != "" ) {firstValidIndex = lastPage_WebView } else {


      for (let i = 0; i < book.spine.length; i++) {
        const item = book.spine.get(i);
        //loger(`Checking spine item ${i}: idref=${item.idref}, href=${item.href}`);
        
        if (item.href) {
          firstValidIndex = i;
          firstValidHref = item.href;
          //loger(`✓ Found first valid spine item at index ${i}: ${firstValidHref}`);
          break;
        } else {
          //loger(`⚠ Spine item ${i} has no href, skipping...`);
          
          // Try to find in manifest by idref
          if (item.idref && book.packaging && book.packaging.manifest) {
            const manifestItem = book.packaging.manifest[item.idref];
            if (manifestItem && manifestItem.href) {
              loger(`✓ Found href in manifest for ${item.idref}: ${manifestItem.href}`);
              item.href = manifestItem.href;
              item.url = manifestItem.href;
              firstValidIndex = i;
              firstValidHref = manifestItem.href;
              break;
            } else {
            // loger(`❌ idref "${item.idref}" not found in manifest - SKIPPING`);
            }
          }
        }
      }
    } 
    
    await book.opened;

    /*
     book.spine.hooks.serialize.register((output, section) => {
    loger('Section href:', section.href);
     });

  
    book.loaed.spine.then(function (spine) {
      loger("Spine lenghth "+ spine.href)
      spine.each(function(item){
        loger("item href "+ item.href)
        loger("item id "+ item.id )
      })
    })*/

    //Parte responsavel por render
    //loger("Step 4: creating rendition.")
    const rendition = book.renderTo("bookArea", {
    width: "100%",
    height: "100%",
    spread: "none",
    
    // PERFORMANCE OPTIMIZATIONS:
    flow: "paginated",      // Faster than "scrolled" for large books
    manager: "default",     // Use default view manager (most stable)
    snap: true,             // Snap to pages (smoother scrolling)
    allowScriptedContent: false,  // Disable if EPUB has no scripts (faster)
    resizeOnOrientationChange: true
  });
  //loger("Rendition created")

  GlobalRendition = rendition

  // Set up rendered event
    rendition.on("rendered", function(section) {
    //Esconde a tela de loading quando renderiza
    document.getElementById("loadingScreen").style.display = "none";
    //window.ReactNativeWebView.postMessage("Hide loadingScreen")  


    //Conta as letras quando acaba de abrir o livro
    if (CurrentWordCount == 0){
    WordCounter(rendition,book).then( (returned) => {
    CurrentWordCount = returned
    //loger(CurrentWordCount)
    })
      }
    
    });

    rendition.on("displayError", function(err) {
      loger("Display error: " + err.message);
    });

    //Responsavel por controla o tamanho da fonte
    const UserFontSizer = ("{{USER_FONTSIZE}}")
    rendition.themes.fontSize(UserFontSizer);


    rendition.display(firstValidIndex);

    await new Promise(resolve => setTimeout(resolve, 300));


    const section = book.spine.get(rendition.currentLocation().start.spine);
    if (section && section.content) {
      // Restaura passando o CFI inteiro (com offset)
      await rendition.display(SAVED_POSITION);
      
      // Força o scroll para o offset específico
      rendition.annotations.highlight(SAVED_POSITION, {}, () => {});
    }

   //Um listener para ser chamada quando muda de pagina
    rendition.on('relocated', function(location) {

    let localiza = rendition.currentLocation().start.cfi
    let string_location = JSON.stringify(localiza)
    window.ReactNativeWebView.postMessage("location:"+string_location)

    //Lida com a logica do WordCounter
    window.ReactNativeWebView.postMessage("pageWordCount: "+CurrentWordCount)

    setTimeout(() => {
    try{

    WordCounter(rendition,book).then( (returned) => {
    CurrentWordCount = returned
    //loger(CurrentWordCount)
    })

/*
    //loger(".01")
    const iframes = document.querySelectorAll('iframe')
    //loger(".02")
    const currentIframe = iframes[iframes.length - 1]
    //loger(".03")

    const doc = currentIframe.contentDocument
    //loger(".04")
    const textContent = doc.body.innerText || doc.body.textContent || '';
    //loger(".05")
    const words = textContent.trim().split(/\s+/).filter(word => word.length > 0);
    loger(".06" + words)
    const wordCount = words.length
    loger(".07 tudo certo wordCount= " + wordCount)*/

  }catch (e) {loger("erro no word counter "+ e)}
    
  },100)
    
    });

  }
  

  base64toByte("{{BASE64_DATA}}")

/*
  if (base64) {
        var byteCharacters = atob("{{BASE64_DATA}}");
        var byteNumbers = new Array(byteCharacters.length);
        for (var i = 0; i < byteCharacters.length; i++) {
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        var byteArray = new Uint8Array(byteNumbers);
        var blob = new Blob([byteArray], {type: "application/epub+zip"});
        var book = ePub(blob);
        var rendition = book.renderTo("bookArea", {width: "100%", height: "100%", spread: "none"});

        rendition.on("rendered", function() {
    // This function is called when a section of the book is rendered and ready
    console.loger("Book section is ready to be displayed");
    document.getElementById("loadingScreen").style.display = "none"
    });

        rendition.display(0)//.then(document.getElementById("loadingScreen").style.display = "none") ;


    } 
*/
    /*
    const WordCounter = () => {
    
      //rendition.getContents
      //rendition.requireView
    } 
    */ 

    //destroy a renderização se mudar de tela, para nao puxar processamento do celular
      window.addEventListener('beforeunload', function() {
    if (book) {
      book.destroy();
   }
   if (rendition) {
     rendition.destroy();
    }
    });
    
    //rendition.on("relocated", TrackBytePos(location))

    document.getElementById('next-zone').addEventListener('click', function() {

      if (GlobalRendition ) {
        GlobalRendition.next()
        window.ReactNativeWebView.postMessage("Page-Next")
      }
          
    })

    document.getElementById('prev-zone').addEventListener('click', function() {
          
      if (GlobalRendition) {
        GlobalRendition.prev()
        window.ReactNativeWebView.postMessage("Page-Prev")  
      }
        
    })


  </script>

</body>
</html>