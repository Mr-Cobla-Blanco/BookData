
<!DOCTYPE html>
<html>

<head>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body, html {
  margin:0;
  padding:0;
  width: 100%;
  height: 100%;
  }

  #bookArea {
    width: 100%;
    height: 100%;
    top: 0;
    left:0; 
    padding-bottom: 7%;
    padding-top: 0 
  }
  
      #nav-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      pointer-events: none;
    }
    .nav-zone {
      flex: 1;
      pointer-events: all;
      cursor: pointer;
    }


</style>

</head>

<body>

  <div id="bookArea"></div>
  <div id="nav-overlay">
   <div class="nav-zone" id="prev-zone"></div>
   <div class="nav-zone" id="next-zone"></div>
  </div>

  <canvas id="canvas"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <script>
    
      window.ReactNativeWebView.postMessage("Webview: Pre-tudo")
          // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';


        window.ReactNativeWebView.postMessage("Webview: starting stuff")

        const Imported_Base64Data = "{{BASE64_DATA}}"
        const cleanImport = Imported_Base64Data.replace(/^data:application\/pdf;base64,/, '');
        //WorkFlow LOAD PDF-> GET A PAGE -> RENDER THE PAGE

        // Convert base64 to Uint8Array
        const binaryString = atob(Imported_Base64Data);
        const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }

        window.ReactNativeWebView.postMessage("Webview: binario resolvido")

        async function getPage(doc, pageNum){

          try{
          window.ReactNativeWebView.postMessage("Webview: getPage chamado")

          //fetch the page
          const page = await doc.getPage(pageNum)

          const viewport = page.getViewport({scale : 1.5})

          const canvas = document.getElementById("canvas")
          const context = canvas.getContext("2d")
          canvas.height = viewport.height
          canvas.width = viewport.width

          window.ReactNativeWebView.postMessage("Webview: getPage para renderizar");

          return await page.render({
            canvasContext: context,
            viewport: viewport
          }).promise
        } catch (error){
          window.ReactNativeWebView.postMessage(error);
        }


        }


        // Load PDF from base64
        async function loadPDF(CompleteData) {
          try {

            window.ReactNativeWebView.postMessage("Webview: Load PDF called1")

            const doc = await pdfjsLib.getDocument({data : CompleteData}).promise

            window.ReactNativeWebView.postMessage("Webview: Load PDF called1")

            let currentPage = 1;

            //Outra função que carrega a pagina indicada
            await getPage(doc, currentPage)

            /*
            //carrega o pdf a partir do array
            const loadingtask = pdfjsLib.getDocument({ data: bytes})
            const pdf = await loadingtask.promise

            window.ReactNativeWebView.postMessage("PDF foi carregado a partir do BASE64")

            //Renderiza a "page"
            const page = await pdf.getPage(1)
            const viewport = page.getViewport({scale : 1.5})

            window.ReactNativeWebView.postMessage("Preparou a pagina")

            const canvas = document.getElementById("bookArea")
            //const context = canvas.getContext('2d')

            canvas.height = viewport.height
            canvas.width = viewport.width

            window.ReactNativeWebView.postMessage("Preparou o espaço a ser renderizado")

            await page.render({
              viewport: viewport
            })

            window.ReactNativeWebView.postMessage("Terminou o processo")*/
            
            
            
          } catch (error) {
            loading.classList.remove('show');
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'error',
              message: 'Failed to load PDF: ' + error.message
            }));
          }
        }

        window.ReactNativeWebView.postMessage("Webview: ImportedBase64 "+Imported_Base64Data.length)
        loadPDF(bytes)


      
      document.getElementById('next-zone').addEventListener('click', function() {
        getPage(doc,currentPage++)
      })

      document.getElementById('prev-zone').addEventListener('click', function() {
        getPage(doc,currentPage--)
      })

        //Função responsavel por contar as palavras em uma pagina
        async function PdfWordCounter() {
          const textContent = await page.getTextContent()

          const fullText = textContent.items.map(item => item.str).join(" ")

          const words = fullText.trim().split(/\s+/).filter(w => w.length > 0);
        }
        
        /*
        // Render specific page
        async function renderPage(pageNum) {
          if (!pdfDoc || rendering) return;
          
          rendering = true;
          currentPage = pageNum;
          
          try {
            // Get page
            const page = await pdfDoc.getPage(pageNum);
            
            // Calculate scale based on container width
            const containerWidth = container.clientWidth - 20;
            const viewport = page.getViewport({ scale: 1 });
            const calculatedScale = containerWidth / viewport.width;
            const finalScale = Math.min(calculatedScale * 1.2, 2.5); // Max 2.5x
            
            // Get final viewport
            const finalViewport = page.getViewport({ scale: finalScale });
            
            // Set canvas dimensions
            canvas.width = finalViewport.width;
            canvas.height = finalViewport.height;
            
            // Render PDF page
            const renderContext = {
              canvasContext: ctx,
              viewport: finalViewport
            };
            
            await page.render(renderContext).promise;
            
            // Extract and count words
            const textContent = await page.getTextContent();
            const pageText = textContent.items
              .map(item => item.str)
              .join(' ');
            
            const words = pageText
              .trim()
              .split(/\\s+/)
              .filter(word => word.length > 0);
            
            // Notify React Native
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'wordCount',
              count: words.length
            }));
            
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'pageChanged',
              pageNum: pageNum
            }));
            
            rendering = false;
            
          } catch (error) {
            rendering = false;
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'error',
              message: 'Failed to render page: ' + error.message
            }));
          }
        }


        /*
        // Navigate to specific page
        function goToPage(pageNum) {
          if (pdfDoc && pageNum >= 1 && pageNum <= pdfDoc.numPages) {
            renderPage(pageNum);
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
          }
        }


        // Swipe detection for page navigation
        let touchStartY = 0;
        let touchStartX = 0;
        let touchEndY = 0;
        let touchEndX = 0;

        canvas.addEventListener('touchstart', (e) => {
          touchStartY = e.changedTouches[0].clientY;
          touchStartX = e.changedTouches[0].clientX;
        }, { passive: true });

        canvas.addEventListener('touchend', (e) => {
          touchEndY = e.changedTouches[0].clientY;
          touchEndX = e.changedTouches[0].clientX;
          handleSwipe();
        }, { passive: true });

        function handleSwipe() {
          const swipeThreshold = 50;
          const diffY = touchStartY - touchEndY;
          const diffX = Math.abs(touchStartX - touchEndX);
          
          // Only trigger if mostly vertical swipe
          if (diffX < swipeThreshold && Math.abs(diffY) > swipeThreshold) {
            if (diffY > 0 && currentPage < pdfDoc.numPages) {
              // Swipe up - next page
              goToPage(currentPage + 1);
            } else if (diffY < 0 && currentPage > 1) {
              // Swipe down - previous page
              goToPage(currentPage - 1);
            }
          }
        }
        //loadPDF(Imported_Base64Data)

        // Expose functions globally
        window.loadPDFData = loadPDF;
        window.goToPage = goToPage;*/

  </script>

</body>
</html>